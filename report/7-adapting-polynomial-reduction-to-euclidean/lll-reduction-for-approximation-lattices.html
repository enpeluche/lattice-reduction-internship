<!DOCTYPE html>

<html lang="fr">
    <head>
        <!-- metadata -->

        <meta charset="UTF-8">
        <meta name="robots" content="index, follow">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <title>Vers une réduction LLL adaptée aux réseaux d’approximation</title>

        <meta
            name="description"
            content="Définition des réseaux d'approximation euclidiens $F_{p^\sigma}$ et introduction de l'algorithme LLL-DAC-Padique. Analyse de la décomposition matricielle $P L F = E$ et des limites de l'algorithme PLE (nécessité de pivots inversibles)."
        >

        <meta
            name="keywords"
            content="réseau d'approximation euclidien, $F_{p^\sigma}$, LLL-DAC-Padique, PLE decomposition, $p^\sigma$-aire, base LLL-réduite, Diviser-pour-Régner, pivots inversibles, réduction p-adique, Gram-Schmidt produit"
        >

        <meta
            name="author"
            content="Lucas Petit"
        >

        <link rel="icon" href="/assets/img/logo/logo.ico" type="image/x-icon">

        <!-- for rendering latex -->

        <!-- CSS -->
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">

        <!-- JS -->
        <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
        <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>
        
        <!-- ALL STYLESHEET -->
 
        <link rel="stylesheet" href="/assets/css/main.css">
    </head>
    <body>
        <header id="main-header-hihi">
            <nav>
                <ul>
                    <li>
                        <a href="../">
                            <svg style="padding-right: 0.5rem" class="flip-horizontal icon backwardArrow" viewBox="0 0 24 24"> <path d="m12 4-1.41 1.41L16.17 11H4v2h12.17l-5.58 5.59L12 20l8-8z"></path> </svg>
                            Réduction de réseaux
                        </a>
                    </li>
                </ul>
            </nav>
        </header>
        
        <main>
            <div id="toc-wrapper"></div>

            <div id="article">
                <h3>Vers une réduction LLL adaptée aux réseaux d’approximation</h3>

                <div class="paragraph">
                    On va donner une définition équivalente du réseau d'approximation \( (F, \sigma) \) mais adaptée pour les réseaux euclidiens.
                </div>

                <div class="definition">
                    Soit \( F \in M_n (\Z) \), un degré de précision \( \sigma \in \N\), et \(p \in \N\). On définit
                    \[
                    F_{p^\sigma} \coloneqq  \{ v \in \Z^n | vF = 0 \mod p^\sigma \}
                    \]
                </div>
                
                <div class="paragraph">
                    Contrairement au cas polynomial, la situation est ici fondamentalement différente.
                    Nous verrons par la suite s’il est nécessaire d’imposer des restrictions sur \( p \) et \( \sigma \),
                    et le cas échéant, lesquelles.
                </div>

                <div class="proposition">
                    \( F_{p^\sigma} \) est un réseau euclidien de dimension \( n \).
                </div>

                <div class="remark">
                    \( F_{p^\sigma} \) est un réseau \( p^\sigma\)-aire.
                </div>

                <div class="paragraph">
                    Comment peut-on calculer une base de \( F_{p^\sigma} \) ?
                    Est-il possible d’en extraire une base \( \mathrm{LLL} \)-réduite, et ce, de manière efficace ?
                    Comme dans le cas polynomial traité pour le réseau \( (F, \sigma) \), il est d'abord nécessaire
                    de calculer une décomposition de la forme
                    
                    $$
                    \begin{equation}
                        \underbrace{
                            \begin{bmatrix}
                                e_{\tau(1)} \\
                                \vdots \\
                                e_{\tau(n)}
                            \end{bmatrix}
                        }_{P}
\cdot
\underbrace{
    \begin{bmatrix}
        L_r & 0 \\
        G & I_{m-r}
    \end{bmatrix}
}_{L}
\cdot
F
=
\underbrace{
    \begin{bmatrix}
        E'\\
        0
    \end{bmatrix}
}_{E}
\end{equation}
$$
où \(r \coloneqq \rang(F) \), \( P \) est une matrice de permutation, \( L \) est une matrice triangulaire inférieure et \( E \) est échelonnée en ligne.


                </div>

                <details>
                    <summary></summary>

                    <p>
                        Il s’agit d’une généralisation de la décomposition \( P L F = U \),
                        où \( U \) était une matrice triangulaire supérieure. Ici, on relâche cette contrainte en ne demandant
                        que \( U \) soit échelonnée par lignes.}
                    </p>
                </details>

                <div class="algorithm">
                    <h2>PLE$(A)$</h2>
                    <div class="meta">
                        <div class="in"> $A \in \mathbb{K}^{n \times m}$</div>
                        <div class="out"> Matrices \( P \), \( L \), \( E \) telles que \( 6.1 \) est satisfaite.</div>
                    </div>

                    $n \gets \text{nrows}(A),\quad m \gets \text{ncols}(A)$ <br>
                    $P \gets I_n, \quad L \gets I_n, \quad E \gets A$
    
                    <div class="for">
                        $i \gets 0$ \KwTo $m{-}1$
            
                        <div class="c">
                            $(pivot, i_{pivot}) \gets Pivot(E_{*,i}, \{i, \dots, n{-}1\})$
        
                <div class="if">
                    pivot = None
                    <div class="c">
                        <span class="keyword">continuer</span>
                    </div>
                </div>

                <div class="if">
                    $i_{pivot} \neq i$
                    
                    <div class="c">
                        Échanger les lignes $i$ et $i_{\text{pivot}}$ dans $P$ et $E$
                        
                        <div class="for">
                            $k \gets 0$ \KwTo $i{-}1$
                            <div class="c">    
                                Échanger $L[i,k]$ et $L[i_{\text{pivot}},k]$
                            </div>
                        </div>
                    </div>        
                </div>
                
                <div class="for">
                    {$j \gets i{+}1$ \KwTo $n{-}1$}
                    <div class="c">
                        $s \gets E[j,i] / \text{pivot}$
                        <div class="conditional">
                            <div class="if">
                                $s \neq 0$
                                <div class="c">
                                    $E \gets E$ avec ligne $j$ <strong>moins</strong> $s$ fois ligne $i$ <br>
                                    $L \gets L$ avec ligne $j$ <strong>moins</strong> $s$ fois ligne $i$
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
       
    
                    <div class="return">$(P, L, E)$</div>
                </div>

                <div class="remark">
                    Comme c'est vrai pour toute permutations, il serait intéressant de choisir certaines permutations particulières,
                    notamment qui ordonne les vecteurs par norme croissante.
                </div>

                <div class="remark">
                    J'ai mis trop d'investissement dans cet algorithme, j'en ai fais plusieurs versions, allant d'une version naïve
                    où je calculais tous les pivots pour ordonner les lignes de façon à avoir les mineurs principaux inversibles,
                    à une stratégie plus subtile d'échange quand nécessaire, grâce aux conseils avisés de mon encadrant. Cet algorithme
                    fonctionne sur \( \Z_p \) pour \( p \) premier, car les pivots sont inversibles, je réfléchissais à une stratégie
                    pour rendre cet algorithme fonctionnel  sur \( \Z_n \).
                </div>

                <div class="theorem">
                    <p>
                        L'algorithme PLE calcule correctement une décomposition qui satisfait 6.1.
                    </p>
                </div>

                <div class="counterexample">
                    <span class="title">Limite de l’algorithme PLE</span> <br>
                    
                    L’algorithme PLE ne s’applique pas dans tous les cas. 
    
                    Soit
                    
                    \[
                    A =
                    \begin{bmatrix}
                        3 & 4 \\
                        4 & 3
                    \end{bmatrix}
                    \in M_2(\mathbb{Z}/12\mathbb{Z}).
                    \]

                    Dans cet anneau, les coefficients \( 3 \) et \( 4 \) ne sont pas inversibles, ce qui empêche de procéder aux opérations
                    de pivot nécessaires. <br>
    
                    Ce contre-exemple montre que la validité de l’algorithme repose sur une hypothèse cruciale :
                    <strong>les pivots doivent être inversibles</strong>. 
                </div>
                
                <div class="example">
                    \[
                    \displaystyle
                    \underbrace{
                        \begin{pmatrix}
                            1 & 0 & 0 & 0 \\
                            -\frac{3}{4} & 1 & 0 & 0 \\
                            -\frac{1}{2} & 0 & 1 & 0 \\
                            0 & -\frac{1}{3} & 0 & 1
                        \end{pmatrix}
                    }_{L}
                    \times
                    \underbrace{
                        \begin{pmatrix}
                            1 & 0 & 0 & 0 \\
                            0 & 0 & 1 & 0 \\
                            0 & 1 & 0 & 0 \\
                            0 & 0 & 0 & 1
                        \end{pmatrix}
                    }_{P}
                    \underbrace{
                        \begin{pmatrix}
                            4 & 2 & 4 & 2 \\
                            2 & 1 & 2 & 1 \\
                            3 & 3 & 3 & 3 \\
                            1 & 1 & 1 & 1
                        \end{pmatrix}
                    }_{F}
                    =
                    \underbrace{
                        \begin{pmatrix}
                            4 & 2 & 4 & 2 \\
                            0 & \frac{3}{2} & 0 & \frac{3}{2} \\
                            0 & 0 & 0 & 0 \\
                            0 & 0 & 0 & 0
                        \end{pmatrix}
                    }_{E}
                    \]
                </div>
                
                <div class="paragraph">
                    On en déduit donc un algorithme pour calculer une base.

                    De 6.1 on déduit que 

                    \[
                    \begin{bmatrix}
                        e_{\tau(1)} \\
                        \vdots \\
                        e_{\tau(n)}
                    \end{bmatrix}
                    \cdot
                    \begin{bmatrix}
                        L_r \cdot p^\sigma & 0 \\
                        G & I_{m-r}
                    \end{bmatrix}
                    \cdot
                    F
                    =
                    \begin{bmatrix}
                        E' \cdot p^\sigma\\
                        0
                    \end{bmatrix}
                    =
                    \begin{bmatrix}
                        0\\
                        0
                    \end{bmatrix}
                    \mod p^\sigma
                    \]
                </div>

                <div class="theorem">
                    <p>
                        Les matrices
                        \[
                        \begin{bmatrix}
                            L_r \cdot p^\sigma & 0 \\
                            G & I_{m-r}
                        \end{bmatrix}
                        \cdot
                        \begin{bmatrix}
                            e_{\tau(1)} \\
                            \vdots \\
                            e_{\tau(n)}
                        \end{bmatrix}
                        , \quad
                        \begin{bmatrix}
                            I_r \cdot p^\sigma & 0 \\
                            G & I_{m-r}
                        \end{bmatrix}
                        \cdot
                        \begin{bmatrix}
                            e_{\tau(1)} \\
                            \vdots \\
                            e_{\tau(n)}
                        \end{bmatrix}
                        \]
                        sont deux bases de \( F_{p^\sigma}\)
                    </p>
                </div>

                <div class="remark">
                    Il vaut mieux privilégier la seconde base car les \(r\) premières lignes sont orthonormées, ce qui nous
                    permet de déduire intuitivement que la base sera de meilleure qualité.
                </div>

                <!--%CA MARCHE QUE QUAND SIGMA VAUT 1-->

                <div class="algorithm">
                    <h2>Basis$(F, p, \texttt{mode})$</h2>

                    <div class="meta">
                        <div class="in"> Une matrice \( F \in \mathbb{K}[x]^{m \times n} \), un scalaire \( p \in \mathbb{K} \), et une chaîne mode égale à v1 ou v2</div>
                        <div class="out"> Une base transformée selon le mode choisi</div>
                    </div>
    
                    $G \gets \text{copie}(F)$<br>
                    $(P, L, E) \gets PLE(G)$ <br>
                    $r \gets \text{rang}(F)$ <br>
    
                    <div class="conditional">
                        <div class="if">
                            mode = v1
                            <div class="c">
                                <div class="for">
                                    $i \gets 0$ \KwTo $r{-}1$
                                    <div class="c">
                                        Multiplier la ligne $i$ de $L$ par $p$
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="conditional">
                        <div class="if">
                            mode = v2
                            <div class="c">
                                <div class="for">
                                    $i \gets 0$ \KwTo $r{-}1$
                                    <div class="c">
                                        Remplacer la ligne $i$ de $L$ par $p \cdot e_i$ <span class="comment">$e_i$ : $i$-ème vecteur de la base canonique</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
      
                    <div class="return">$L \cdot P$</div>
                </div>

                <div class="example">
                    En partant de la matrice 
                    \(
                    F = 
                    \begin{pmatrix}
                        4 & 2 & 4 & 2 \\
                        2 & 1 & 2 & 1 \\
                        3 & 3 & 3 & 3 \\
                        1 & 1 & 1 & 1
                    \end{pmatrix}
                    \)
    
                    On peut calculer une base de \( F_{5^4}\)
    
                    \[
                    \begin{pmatrix}
                        625 & 0 & 0 & 0 \\
                        -\frac{1}{2} & 1 & 0 & 0 \\
                        0 & 0 & 625 & 0 \\
                        0 & 0 & -\frac{1}{3} & 1
                    \end{pmatrix}
                    \]
                </div>
                
                <div class="paragraph">
                    On peut donc maintenant définir un algorithme sur un principe diviser pour régner.
                </div>
  
                <div class="algorithm">
                    <h2>LLL-DAC-Padique$(F, p, \sigma)$</h2>

                    <div class="meta">
                        <div class="in"> $F \in \mathbb{K}^{m \times n}$, un entier premier $p$, un entier $\sigma \geq 1$</div>
                        <div class="out"> Une base "LLL-réduite?" en précision $p^\sigma$</div>
                    </div>
    
    
                    <div class="conditional">
                        <div class="if">
                            $\sigma = 1$
                            <div class="c">
                                <div class="return"> $LLL(ApproximantBasis(F, p))$</div>
                            </div>
                        </div>
                    </div>
    
    
                    $\tau \gets \left\lfloor \dfrac{\sigma + 1}{2} \right\rfloor$ <br>
    
                    $V_1 \gets LLL-DAC-Padique(F, p, \tau)$ <span class="comment">Appel récursif sur demi-précision</span><br>
    
                    $F_{\text{low}} \gets \dfrac{V_1 \cdot F}{p^\tau}$ <span class="comment">Mise à jour du problème</span><br>
    
                    $V_2 \gets LLL-DAC-Padique(F_{\text{low}}, p, \sigma - \tau)$ <span class="comment">Appel récursif décalé</span>

                    <div class="return">$V_2 \cdot V_1$</div>
                </div>

                <div class="paragraph">
                    Similairement à la preuve du chapitre précédent, \(V_2 V_1\) est une base de \( F_{p^\sigma} \).
                </div>

                <div class="problem">
                    <span class="title"> <strong> (Question)</strong></span> <br>
                    Dans quelle mesure le produit de matrices LLL-réduites reste-t-il lui-même LLL-réduit ?
                    Peut-on quantifier cette propriété ?
                </div>

                <div class="paragraph">
                    Si \( V_1 \) est une matrice orthogonale, c'est-à-dire dont les lignes sont orthonormées,
                    alors \( V_2 V_1\) est \( \mathrm{LLL}\)-réduite.

                    On rappelle que \( V_1 = U_1 V_1^* \) d'après le procédé de Gram-Schmidt. <br>
                    <span class="nowrap">En écrivant \( V_1 V_2 = V_1 V_2^* ((V_2^*)^{-1} U_2 V_2^*) \), peut-être pourront nous mieux contrôler
                    le résultat du produit.</span>
                </div>
            </div>

        </main>

        <footer id="main-footer"></footer>
        
        <script type="module" src="/assets/js/main.js"></script>
    </body>
</html>